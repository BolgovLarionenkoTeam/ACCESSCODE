

Илья Болгов

Артем Ларионенко

accesscode

ACCESSCODE

PROJECT

Весна 2021






Содержание

1 Введение

ACCESSCODE PROJECT это инженерный проект по информатике, который представляет

из себя дополнительный модуль расширения, которым можно укомплектовать практически

любой полноразмерный ПК с целью повышения его физической защиты от проникновения.

Модуль представляет из себя плату Arduino MEGA с подключенными модулями и датчиками

и позволяет блокировать доступ к ПК с помощью обесточивания блока питания ПК и блоки-

ровки замков от корпусных дверей, а также имеет систему сигнализации, при срабатывании

которой может запускаться функция физического самоуничтожения твердотельного нако-

пителя (SSD) ПК. Контроль над блокировкой и разблокировкой доступа к ПК, а также над

дополнительными функциями происходит с помощью кейпада, RFID-модуля, сканера отпе-

чатков пальцев, а также удаленно с помощью GSM-shield’a.

Система сигнализации включает в себя акселерометр, который фиксирует передвижения

ПК и ультразвуковой датчик расстояния, который фиксирует открытия дверей корпуса.

Система самоуничтожения заключается в принудительном физическом уничтожении твер-

дотельного накопителя (SSD) внутри компьютера с помощью термитной смеси (подробнее см.

§2.5).

Разблокировка компьютера с этим модулем состоит из трех этапов: на первом этапе вла-

делец ПК прикладывает к ридеру, встроенному в модуль, свою RFID-карту, на втором - к

датчику отпечатков пальцев свой палей, а на третьем - вводит на кейпаде пин-код, который

был случайно сгенерирован и отправлен ему через СМС. (подробнее см. §4.3)

Модуль устанавливается внутрь корпуса ПК и подключается к блоку питания на уровне

реле, тем самым давая возможность напрямую контролировать питание ПК, а также для

работы модуля необходимо наличие возможности вывода из корпуса кейпада, датчика отпе-

чатков пальцев и RFID-модуля.

Помимо необходимости при каждом включении прикладывать RFID-карту, отпечаток

пальцев и вводить случайно сгенерированный пин-код присылаемый через СМС, компьютер

остается полностью функционирующим и с программной точки зрения совершенно не отлича-

ется от обычного ПК.

1 Введение

3

1.1 Принцип работы - краткое описание ................................................................................. 4

2 Сборка схемы

5

5

2.1 Описание компонентов

2.1.1 Плата и микроконтроллер ........................................................................................ 5

2.1.2 RFID-модуль ............................................................................................................. 5

2.1.3 Датчик отпечатков пальцев ...................................................................................... 5

2.1.4 Кейпад ....................................................................................................................... 6

2.1.5 Акселерометр ............................................................................................................. 6

2.1.6 Ультразвуковой датчик расстояния ......................................................................... 7

2.1.7 Звуковой модуль с динамиком.................................................................................. 7

2.1.8 Реле ............................................................................................................................ 8

2.1.9 Электрозамки ............................................................................................................ 8

2.1.10 GSM-Shield ................................................................................................................ 8

2.2 Построение схемы ............................................................................................................... 9

2.2.1 Таблица подключений .............................................................................................. 9

2.2.2 Схема подключения и питания ................................................................................. 9

2.3 Моддинг корпуса ПК ......................................................................................................... 11

2.4 Модуль самоуничтожения ................................................................................................. 11

3 Разработка

15

3.1 Использованные библиотеки ..............................................................................................15

3.2 Методы и функции ............................................................................................................ 16

3.3 Описание алгоритмов .........................................................................................................18

4 Использование

19

Модуль имеет свой аккумулятор и при подключении ПК к сети находится в состоянии

постоянной подзарядки, благодаря этому при отсутствии питания ПК может автономно рабо-

тать без GSM-Shield’a на протяжении некоторого времени.

4.1 Настройка и загрузка прошивки ....................................................................................... 19

4.2 Первое включение .............................................................................................................. 20

4.3 Блокировка и разблокировка ............................................................................................ 20

4.4 Функции устройства ...........................................................................................................21

Благодаря акселерометру, ультразвуковому датчику расстояния и замкам на корпусе, лю-

бая попытка вытащить SSD будет бессмысленна, так как вызовет его уничтожение.

Этот модуль можно использовать также без функции самоуничтожения, а в качестве сиг-

нализации и средства защиты компьютера от физического проникновения. В таком случае

при попытке проникновения корпус ПК будет заблокирован, блок питания выключен, а вла-

дельцу ПК будет отправлено уведомление, что его компьютер подвергся атаке.

Объективно говоря, режим самоуничтожения в ПК является очень специфической функ-

цией, практически не имеющей практическое применение, однако никто не говорил, что так

нельзя сделать, верно?

5 Описание прототипа и заметки

6 Ссылки

22

23

24

7 Приложения

7.1 accesscode.ino // программный код ................................................................................... 24

accesscode

Логотип проекта

2

3





1.1 Принцип работы - краткое описание

2 Сборка схемы

При включении модуля пользователю дается 30 секунд на то, чтобы закрыть крышку сво-

его компьютера и установить его на место, после этого включается режим блокировки. После

того, как инициализация завершилась, звучит звуковой сигнал и включается режим защиты.

В режиме защиты любое передвижение ПК, или открытие корпуса приведут к срабатыва-

нию сигнализации, следовательно к самоуничтожению.

В режиме защиты боковые двери корпуса заблокированы, а блок питания ПК отключен.

Чтобы отключить режим защиты, необходимо приложить RFID-карту к RFID-модулю,

затем, палец к отпечатку пальцев. После этого в течении нескольких секунд приходит СМС с

случайно сгенерированным пин-кодом, который нужно ввести в кейпад. После этого устрой-

ство выходит из режима защиты.

2.1 Описание компонентов

Основные компоненты проекта:

Arduino Mega 2560 Rev3

RFID-модуль MFRC522

Датчик отпечатков пальцев FPM10A

Кейпад

Акселерометр MPU6050

Ультразвуковой датчик расстояния HC-SR04

Звуковой модуль с динамиком

Реле 5V x2

Электрозамки 12V x2

GSM-Shield SIM900

После двух неудачных попыток ввода пин-кода происходит выход из режима разблокиров-

ки (включается после ввода RFID). Также из режима разблокировки можно выйти нажатием

клавиши на кейпаде.

После двух неправильных попыток ввода пин-кода устройство выходит из режима ввода

пин-кода (необходимо заново вводить карту и отпечаток пальца). Также выйти из режима

ввода можно с помощью кейпада.

После отключения защиты пользователь может включить ПК, а также разблокировать

двери корпуса от клавиши на кейпаде.

Датчики движения/расстояния не активны при выключенной защите.

Блокировка устройства происходит от нажатия клавиши на кейпаде.

Функция самоуничтожения может быть вызвана через кейпад на заблокированном или

разблокированном устройстве, при передвижении или вскрытии корпуса, а также от СМС

владельца.

В коде предусмотрена возможность экстренной блокировки/разблокировки через СМС от

владельца, или через мастер-пароль, которые можно отключить. Также предусмотрена воз-

можность удаленного запуска самоуничтожения через СМС.

Многие из этих комплектующих опциональны, также почти всё можно заменить аналога-

ми. При доработке проект может быть изготовлен на печатной плате и поставлен на серийное

производство.

2.1.1 Плата и микроконтроллер

За основу проекта была взята платформа Arduino, ввиду своей удобности для создания

подобных прототипов, а именно плата с микроконтроллером Arduino Mega 2560. Выбор пал

на эту плату из-за количества цифровых и аналоговых разъемов, которые были необходимы

для подключения избыточного количество модулей, необходимых для функционирования си-

стемы.

При блокировке, разблокировке, открытии дверей корпуса и включении на устройство вла-

дельца приходят СМС-оповещения.

При выключении ПК от электросети GSM-Shield теряет питание, поэтому разблокировать

не включенный в сеть ПК невозможно (только при включенном мастер-пароле).

2.1.2 RFID-модуль

В проекте используется RFID-модуль MFRC522, с помощью него совершается авторизация

в устройство. В программном коде (см. Приложение 1) в переменной записан UID карты вла-

дельца ПК, с помощью которой производится разблокировка.

Подробнее об использованной для этого модуля библиотеке в §3.1.

2.1.3 Датчик отпечатков пальцев

В проекте был использован датчик отпечатков пальцев FPM10A. Датчики владельца ПК

записываются в память датчика с помощью встроенного скрипта и хранятся на нем в зашиф-

рованном виде. Подробнее об использованной для этого модуля библиотеке в §3.1.

Датчик отпечатков пальцев используется при авторизации в устройство.

4

5





2.1.4 Кейпад

2.2 Построение схемы

В проекте был использован аналоговый кейпад 4x4 для ввода пин-кодов и управления устрой-

ством и авторизации. Кейпад работает по принципу матричной клавиатуры - несколько

кнопок соединяются в прямоугольную матрицу, располагаясь в узлах рядов и столбцов из

проводников.

В этом разделе будет описано подключениие всех модулей к плате и питание платы и моду-

лей при установке в ПК.

В таблице в пункте 2.2.1 записаны подключения каждого из модулей.

Более подробная схема подключения - в пункте 2.2.2.

2.1.5 Акселерометр

2.2.1 Таблица подключений

В проекте был использован акселерометр MPU6500, который реагирует на передвижения ПК

и вызывает срабатывание сигнализации при перемещении ПК.

SDA

SCK

MOSI

MISO

RST

GND

VCC

pin1

pin2

pin3

pin4

pin5

pin6

pin7

pin8

VCC

TRIG

ECHO

GND

VCC

GND

IN

D53

D52

D51

2.1.6 Ультразвуковой датчик расстояния

RFID

D50

Использованный в проекте ультразвуковой датчик расстояния является частью системы

сигнализации и устанавливается направленным в боковую дверь ПК с целью следить за её

открытием.

D5

GND 3.3V

VCC 3.3V

D13

2.1.7 Звуковой модуль с динамиком

D12

D11

Для работы звуковых уведомлений в проекте использовался звуковой модуль с динамиком.

Он воспроизводит звуковые файлы с памяти SD-карты, установленной внутри него.

D10

Кейпад

D9

D8

2.1.8 Реле

D7

В проекте предполагается использование двух релейных модулей 5В: один устанавливается

внутрь блока питания ПК и встает в разрыв между силовым проводом, чтобы контролиро-

вать питание БП; второй устанавливается в разрыв между 12В питанием электрозамка, кото-

рый блокирует открытие корпуса при включенной защите.

D6

VCC 5V

D31

Ультразвуковой

сенсор

D30

GND 5V

VCC 5V

GND 5V

D4

2.1.9 Электрозамки

Реле БП

С целью защиты от физического отключения модуля защиты, в корпусе установлен электро-

замок, который блокирует его открытие изнутри.

VCC

GND

SCL

SDA

VCC

GND

TX

VCC 5V

GND 5V

D21 (SCL)

D20 (SDA)

VCC 3.3V

GND 3.3V

D18

Акселерометр

2.1.10 GSM-Shield

GSM-Shield служит средством коммуникации устройства с внешним миром: с помощью него

отправляются уведомления о состоянии устройства, случайно сгенерированные пин-коды для

авторизации, а также с помощью него работает функция удаленного самоуничтожения.

Датчик

отпечатков

пальцев

RX

D19

VCC

GND

IN

VCC 5V

GND 5V

???

Реле Замки

6

7





2.2.2 Схема подключения и питания

2.4 Моддинг корпуса ПК

Для вывода из корпуса кейпада и датчика отпечатка пальцев в нем были сделаны отвер-

стия, через которые они были выведены и приклеены. Также было сделано отверстие для

вывода антенны GSM.

Для этого проекта был специально выбран корпус, в котором блок питания не выводится

полностью на задней стенке корпуса, а устанавливается внутри корпуса и проводится за

корпус с помощью удлинителя. Таким образом от блока питания за корпус выводится лишь

силовой разъем питания. Благодаря этой особенности появилась удобная возможность внутри

корпуса подключить 12В блок питания к силовому кабелю, идущему к БП ПК.

Внутри самого блока питания было установлено реле, с помощью которого можно контро-

лировать питание компьютера с помощью Arduino.

Для улучшения визуальной составляющей была изготовлена алюминиевая накладка, раз-

работанная в среде 3D моделирования Autodesk Fusion 360, покрывающая верхнюю часть

фронтальной части корпуса, в которой находятся кейпад и датчик отпечатков пальцев.

2.5 Модуль самоуничтожения

В качестве концепции модуля самоуничтожения предлагается использование сервопривода,

который включает зажигательное устройство (пр. зажигалка), которая, в свою очередь, под-

жигает магниевую ленту, которая поджигает термитную смесь, расположенную на SSD-нако-

пителе.

Термитная смесь — порошкообразная смесь алюминия с оксидами различных металлов

(обычно железа). При воспламенении интенсивно сгорает с выделением большого количества

тепла. Обычно имеет температуру горения 2300—2700 °C.

Небольшого количества термитной смеси будет достаточно для безвозвратного уничтоже-

ния памяти устройства.

Модуль защиты уже имеет функцию запуска самоуничтожения, которая запускает серво-

привод: единственное, что остается – просто установить зажигатель и термитную смесь в ПК.

Для питания устройства

в корпусе был установлен

блок питания на 12В для

GSM-Shield и электрозам-

ков, а также понижающий

модуль на 5В для питания

платы.

8

9





3 Разработка

3.3 Описание алгоритма

Основной цикл loop() (см. Приложение 1, строчка 462) состоит из нескольких крупных

условий, каждое из которых включает свои полусловия и проверки каждого этапа работы.

Первое условие отвечает за то, чтобы при постановке системы на блокировку запускалась

непосредственно функция защиты (protection ())

Все следующие условия отвечают за вывод системы из режима защиты в обычный режим

работы.

В данном разделе описывается более подробное рассмотрение прошивки проекта: принципы

его создания, концепция работы системы и последующая реализация.

Прошивка проекта написана на модифицированных версиях двух языков: C и C++, а также

она объединяется с библиотекой AVR Libc для более удобного создания скетчей (программ)

на платформе Arduino.

Здесь поочерёдно проверяются все стадии верификации пользователя. Для начала проис-

ходит опрос RFID-модуля на приложенную карту, и пока её идентификационный номер не

будет таким же, что и тот, который указан в прошивке, система не перейдет на следующий

этап.

После удачной проверки карты запускается опрос сканера отпечатка пальцев. Алгоритм

работы аналогичен предыдущей стадии: датчик отпечатка пальцев ожидает поднесения

пальца и после проверяет очередной скан отпечатка с сохранённым в прошивке. После чего

система переходит на завершающую стадию верификации пользователя.

На данной стадии в работу вступает кейпад. После того, как была отсканирована правиль-

ная карта и приложен верный палец, система генерирует уникальный 6-значный код пароль,

который после этого отправляется на мобильное устройство с помощью функции sendPin().

После отправки сообщения начинается опрос кейпада для того, чтобы пользователь мог

ввести код. Если всё введено верно, то запускается функция unlockSystem(), которая выводит

систему в рабочее состояние.

3.1 Использованные библиотеки

В проекте было использованы различные библиотеки для работы с модулями, а также для

воплощения в жизнь некоторых функций системы:

“Adafruit\_Fingerprint.h” – библиотека для работы с датчиком отпечатков пальцев (см. п.

2.1.3)

\- “SoftwareSerial.h“ – библиотека для реализации последовательного интерфейса на любых

цифровых выводах Arduino с помощью программных средств

\- “Keypad.h” – библиотека для работы с кейпадом при помощи использования аналоговых вы-

ходов Arduino (см. п. 2.1.4)

\- “Servo.h” – библиотека для работы с сервоприводом, который участвует в работе модуля

самоуничтожения (см. п. 2.5)

\- “SPI.h” – библиотека для использования датчиков, требующих подключения по шине SPI

(последовательному периферийному интерфейсу, работающем на высоких скоростях)

\- “I2Cdev.h” – библиотека дли использования датчиков, требующих подключения по интер-

фейсной шине I2C (данные передаются всего по 2 проводам)

\- “MPU6050.h” – библиотека для использования акселерометра (см. п. 2.1.5)

\- “RedMP3.h” – библиотека для работы с звуковым модулем через последовательный интер-

фейс (см. п. 2.1.7)

Также на этом этапе пользователь может ввести код для запуска системы самоуничтоже-

ния, нажав на клавишу «D», не дожидаясь кода в SMS.

После разблокировки на кейпаде может быть нажата клавиша «С», позволяющая открыть

корпусные замки

На каждом этапе можно сбросить введённые данные, нажав на символ «\*»

\- “MFRC522.h” – библиотека для удобного подключения и использования RFID-модуля (см. п.

2.1.2)

3.2 Методы и функции

Прошивка построена на отдельных методах и функциях, которые сливаются воедино в бес-

конечном цикле loop()

setup() – функция инициализации, подключения и начальной настройки всех модулей и

систем проекта для дальнейшей работы

recieveFingerprint() – функция для получения данных о приложенном к датчику отпечат-

ков пальце и последующей обработки и сравнения с базой данных отпечатков.

sendSms() – функция, позволяющая отправлять SMS-уведомления на мобильное устройство

с помощь GSM-шилда (см. п. 2.1.10)

sendPin() – функция, генерирующая уникальный код-пароль для входа в систему

destruction() – функция самоуничтожения, запускающая процессы модуля самоуничтоже-

ния (см. п. 2.5)

protection() – функция, опрашивающая ультразвуковой датчик расстояния и акселерометр

на предмет изменения положения корпуса в пространстве

blockSystem() и unlockSystem() – функции, отвечающие за блокировку и разблокировку

системы

updateGsm() – функция для получения данных с мобильного устройства через SMS и даль-

нейшего анализа этих данных

passwordInput() и checkPassword() – функции для ввода кода-пароля с клавиатуры и после-

дующего сравнения с истинным кодом разблокировки или мастер-паролем.

10

11





4 Использование

4.5 Функции устройства

Устройство в разблокированном режиме имеет возможность разблокировки боковой двери

корпуса нажатием на ‘C‘: после этого замок разблокируется на 15 секнуд.

Нажатие на кнопку ‘D‘ с последующим введением пароля для самоуничтожения в любом

режиме работы устройства вызывает функцию самоуничтожения.

В данном разделе будет описан процесс использования модуля ACCESSCODE вместе с ПК,

на базе которого установлен модуль, а также основные детали касательно начала работы и

функций устройства.

Одна из важнейших функций устройства - возможность управления устройством через

СМС сообщения: существует три пароля, отправя на номер устройства которые вы можете

разблокировать, заблокировать, или вызвать функцию самоуничтожения.

Также стоит отметить то, что устройство практически полностью автономно (кроме GSM)

и может работать в течении недели от встроенного аккумулятора. Таким образом, при отклю-

чении питания из сети, защита продолжает работать.

4.1 Настройка и загрузка прошивки

Перед началом сборки устройства необходимо прошить плату, на базе которой будет соби-

раться модуль защиты. В программном коде есть несколько переменных, которые владельцу

устройства нужно отредактировать под себя:

#deﬁne PHONE\_NUMBER «+79\*\*\*\*\*\*\*\*\*» // номер телефона владельца

String MASTER\_PASSWORD = «\*\*\*\*\*\*»; // мастер-пароль (рекомендуется отключить в прошив

ке)

Стоит также упомянуть о функции выхода из режима авторизации нажатием на «\*».

String TRUE\_RFID\_ID\_1 = «\*\*\*\*\*\*\*\*\*\*\*\*\*»; // UID RFID-карты

String TRUE\_PASSWORD\_DESTRUCT = «\*\*\*\*\*\*»; // пароль для самоуничтожения системы через

кейпад

5 Описание прототипа и заметки

String SELF\_DESTRUCTION\_SMS = «79\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*»; // первые цифры - номер телефона

владельца, затем 6-и значный пароль для самоуничтожения через СМС

String UNLOCK\_SMS = «79\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*»; // первые цифры - номер телефона владельца,

затем 6-и значный пароль для разблокировки через СМС (рекомендуется отключить в про

шивке)

String LOCK\_SMS = «79\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*»; // первые цифры - номер телефона владельца,

затем 6-и значный пароль для блокировки через СМС (рекомендуется отключить в прошив

ке)

Прототипом является ПК с установленным модулем физической защиты ACCESSCODE.

ПК собран на базе процессора AMD A8-9600 на сокете AM4 и материнской платы ASRock

на чипсете A320M форм-фактора Mini-ITX с 16 Гб DDR4 RAM.

Сборка в корпусе STREACOM DA2, в котором были вырезанны отверстия под датчик от-

печатков пальцев и кейпад.

Также на корпусе была размещена декоративная накладка на передней панели.

Этот корпус был выбран из-за удобного модульного расположения комплектующих.

На ПК установлен дистрибутив ОС Kali Linux 2021.1, дизайн которого был кастомизирован

под проект.

После редактирования кода необходимо его скомпилировать и прошить плату через USB

COM-порт.

\* В версии прототипа v.1.0 отсутствует электрозамок, а также функция защиты от DDos

атаки на RFID и GSM модули и функция автоматического включения модуля GSM, которые

будут добавлены в следующих версиях.

4.3 Первое включение

Первое включение происходит при открытом корпусе. Благодаря проверке датчика рас-

стояния система защиты не включается, когда корпус открыт, а вместо ее включения модуль

уходит в «режим настройки» и срабатывает короткий звуковой сигнал. После того, как вся

работа внутри корпуса будет закончена, для включения системы защиты необходимо нажать

на кнопку ‘C’ на кейпаде, после этого будет включен «режим защиты».

Стоит отметить, что в дальнейшем, при включении модуля при закрытом корпусе всегда

будет сразу запускаться «режим защиты».

4.4 Блокировка и разблокировка

Для разблокировки устройства нужно пройти трехэтапный алгоритм аутентификации,

который включает в себя RFID-карту, датчик отпечатков пальцев, а также ввод случайно

сгенерированного пин-кода, отправленного через СМС.

Первый шаг: приложите RFID-карту к кейпаду (за ним в прототипе распологается

RFID-сканер). После того, как вы услышите звуковой сигнал, переходите ко второму шагу.

Второй шаг: приложите палец к датчику отпечатков пальцев. При удачном срабатывании

вы услышите звуковой сигнал.

Третий шаг: в течении нескольких секунд после второго шага, на ваш телефон придет

СМС с уникальным пин-кодом для входа в систему. Нажмите ‘А‘ и введите 6-и значный пин-

код. Вы авторизовались в системе и теперь блок питания ПК включен, а датчики сигнализа-

ции (ультразвуковой датчик открытия корпуса и акселерометр) отключены.

Для блокировки вам необходимо нажать на кнопку ‘B‘ на кейпаде.

12

13





6 Ссылки

7 Приложениия

7.1 accessCode.ino // Программный код

\1. Adafruit Fingerprint Library - https://github.com/adafruit/Adafruit-Fingerprint-

Sensor-Library

\1.

\2.

// Main executable ﬁle of the ACCCESCODE project – v.1.0

\3. //----------------------------------------LIBRARIES----------------------------------------------------

\2. i2cdevlib - https://github.com/jrowberg/i2cdevlib

\3. mpu6050 - https://github.com/ElectronicCats/mpu6050

\4. RedMP3 - https://github.com/artronshop/OPEN-SMART-RedMP3

\5. Arduino, official site - https://www.arduino.cc/

\6. MCG 5184, Mechatronics Laboratory Manual, Theja Ram Pingali

\7. Seytonic, Self Destructing SSD - https://www.youtube.com/

watch?v=1ecB7xaHkeE

\4.

\5.

\6.

\7.

\8.

\9.

\10.

\11.

\12.

\13.

#include <Adafruit\_Fingerprint.h>

#include <SoftwareSerial.h>

#include <Keypad.h>

#include <Servo.h>

#include <SPI.h>

#include ”I2Cdev.h”

#include ”MPU6050.h”

#include ”RedMP3.h”

#include <MFRC522.h>

\14. //----------------------------------------DEFINES------------------------------------------------------

\15.

\16.

\17.

\18.

\19.

\20.

\21.

\22.

\23.

\24.

\25.

\26.

#deﬁne mySerial Serial1

#deﬁne TIME\_OUT 20

#deﬁne MP3\_RX 38 // pin RX player

#deﬁne MP3\_TX 39 // pin TX player

#deﬁne RST\_PIN 5 // pin RST RFID scanner

#deﬁne SS\_PIN 53 // pin SS RFID scanner

#deﬁne PIN\_TRIG 31 // TRIG pin of the distance sensor

#deﬁne PIN\_ECHO 30 // ECHO pin of the distance sensor

#deﬁne PIN\_POWER\_SUPPLY 4 // logic pin of the power supply relay

#deﬁne PIN\_LOCKS 2 //logic pin of the locks relay

#deﬁne RESET\_PIN 3

Inspired by Mr. Robot.

\27. //----------------------------------------SOUNDS-------------------------------------------------------

\28.

\29. //sounds

\30.

\31.

\32.

\33.

\34.

\35.

\36.

\37.

\38.

#deﬁne BLOCK\_SOUND 0x03 // lock sound

#deﬁne UNLOCK\_SOUND 0x03 // unlock sound

#deﬁne TRUE\_INPUT\_SOUND 0x01 // sound of correct login (for RFID, Fingerpint)

#deﬁne FALSE\_INPUT\_SOUND 0x05 // sound of incorrect login (for RFID, Fingerpint)

#deﬁne KEYBOARD\_SOUND 0x01 // sound of pressing the keyboard

#deﬁne DESTRUCTION\_SOUND 0x02 // self-destruction sound

#deﬁne TRUE\_INPUT\_SOUND\_2 0x06 // sound of correct login

#deﬁne DOOR\_SOUND 0x07 // very special sound

\39. //volume

\40.

\41.

\42.

\43.

\44.

\45.

\46.

#deﬁne BLOCK\_VOLUME 0x1c // lock sound volume

#deﬁne UNLOCK\_VOLUME 0x1a // unlock sound volume

#deﬁne TRUE\_INPUT\_VOLUME 0x1a // sound volume of correct login

#deﬁne FALSE\_INPUT\_VOLUME 0x16 // sound volume of incorrect login

#deﬁne KEYBOARD\_VOLUME 0x16 // volume of the sound of pressing the keyboard

#deﬁne DESTRUCTION\_VOLUME 0x16 // self destruct sound volume

\47. //time

\48.

\49.

\50.

\51.

\52.

\53.

\54.

#deﬁne BLOCK\_TIME 1500 // duration of the lock sound (мс)

#deﬁne UNLOCK\_TIME 1500 // duration of the unlock sound (мс)

#deﬁne TRUE\_INPUT\_TIME 1500 // sound duration of correct login (мс)

#deﬁne FALSE\_INPUT\_TIME 1000 // sound duration of incorrect login (мс)

#deﬁne KEYBOARD\_TIME 50 // duration of sound of pressing the keyboard (мс)

#deﬁne DESTRUCTION\_TIME 19000 // self-destruction sound duration (мс)

\55. //----------------------------------------NOTIFICATIONS------------------------------------------------

\56.

\57.

\58.

\59.

\60.

\61.

\62.

\63.

#deﬁne PHONE\_NUMBER ”+79632925313”

#deﬁne UNLOCK\_NOTIFY “Your system was unlocked\nACCESSCODE” // message text for unlock process

#deﬁne DOORS\_NOTIFY “Side doors on your system were unlocked\nACCESSCODE” // message text for opening doors

#deﬁne DESTRUCTION\_NOTIFY “ !!! SELF-DESTRUCTION PROCESS WAS STARTED !!!\nACCESSCODE” // message text for destruction process

#deﬁne WELCOME\_NOTIFY “Your protection system is up\nACCESSCODE”

#deﬁne SETUP\_NOTIFY “Your protection system is turned on in setup mode: the side doors are open\nACCESSCODE”

\64. //----------------------------------------CONSTANTS----------------------------------------------------

\65.

\66.

\67.

\68.

\69.

\70.

\71.

\72.

\73.

\74.

\75.

\76.

\77.

\78.

\79.

\80.

String MASTER\_PASSWORD = ”000000”; // will remove

String RECIEVED\_PASSWORD;

String TRUE\_RFID\_ID\_1 = “772”; //ID of RFID carf

String TRUE\_RFID\_ID\_2 = ”4294946563”;

String TRUE\_PASSWORD\_UNLOCK = “000000”; //sms login password

String TRUE\_PASSWORD\_DESTRUCT = “159753”; //self-destruction password

int COUNTER\_LIMIT = 5; // delay in seconds for resetting the event counter

int COUNTER\_MAX\_EVENTS = 5; // number of gyro position changes before starting self-destruction

int MAX\_LENGTH\_SONAR = 10; // distance between distance sensor and side cover

String SELF\_DESTRUCTION\_SMS = ”79632925313639582”; // +79632925313, 639582

String UNLOCK\_SMS = ”79632925313758963”; // +79632925313, 758963

String LOCK\_SMS = ”79632925313539754”; // +79632925313, 539754

\81. //----------------------------------------OTHER\_INITIALISATIONS----------------------------------------

\82.

\83.

\84.

\85.

MPU6050 accgyro;

Adafruit\_Fingerprint ﬁnger = Adafruit\_Fingerprint(&mySerial);

Servo myservo;

14





\86.

\87.

\88.

\89.

\90.

\91.

\92.

\93.

\94.

\95.

\96.

\97.

\98.

\99.

\100.

MFRC522 mfrc522(SS\_PIN, RST\_PIN);

MP3 mp3(MP3\_RX, MP3\_TX);

unsigned long int t1;

const byte ROWS = 4; // number of lines in the keyboard

const byte COLS = 4; // the number of columns in the keyboard

char keys[ROWS][COLS] = {

{‘1’,’2’,’3’,’A’},

{‘4’,’5’,’6’,’B’},

{‘7’,’8’,’9’,’C’},

{‘\*’,’0’,’#’,’D’}

\181. int ax, ay, az, gx, gy, gz;

\182. accgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

\183. low\_x = ax - 1000;

\184. low\_y = ay - 1000;

\185. low\_z = az - 1000;

\186. high\_x = ax + 1000;

\187. high\_y = ay + 1000;

\188. high\_z = az + 1000;

\189. delay(100);

\190.

};

\191. Serial.println(”INITIALIZATION COMPLETED”);

\192. delay(500);

\193. playSound(BLOCK\_SOUND, BLOCK\_VOLUME, BLOCK\_TIME);

\194. sendSms(WELCOME\_NOTIFY);

\195. }

byte rowPins[ROWS] = {9,8,7,6}; // rows connection pins

byte colPins[COLS] = {13,12,11,10}; // collumns connection pins

Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );

\101. int pos = 0; // home position of the servo in degrees

\196.

\102.

\197. void resetFunc(){

\103. long DURATION\_SONAR, LENGTH\_SONAR;

\198.

digitalWrite(RESET\_PIN, LOW);

\104. int low\_x, low\_y, low\_z;

\105. int high\_x, high\_y, high\_z;

\199. }

\200.

\106. int COUNTER\_EVENTS = 0;

\201. bool checkFingerprint(int current){ // checking the scanned ﬁngerprint for presence in the database

\107. int COUNTER = 0;

\202.

if (current != 0){

\108. int ﬁngerIDS = 0;

\203.

playSound(TRUE\_INPUT\_SOUND, TRUE\_INPUT\_VOLUME, TRUE\_INPUT\_TIME);

\109.

\204.

return true;

\110. char key;

\205.

}

\111. String notify;

\206.

else{

\112.

\207.

return false;

\113. String messageCheck;

\208.

}

\114.

\209. }

115.//----------------------------------------BOOLS--------------------------------------------------------

\210. bool recieveFingerprint() { // obtaining a print using a scanner

\116.

\211.

\212.

\213.

\214.

\215.

\216.

\217.

\218.

\219.

\220.

\221.

\222.

\223.

\224.

\225.

\226.

\227.

\228.

\229.

\230.

\231.

\232.

\233.

\234.

\235.

\236.

\237.

\238.

\239.

\240.

\241.

\242.

\243.

\244.

\245.

\246.

\247.

\248.

\249.

\250.

\251.

\252.

\253.

\254. }

\255.

protection();

uint8\_t p = ﬁnger.getImage();

switch (p) {

case FINGERPRINT\_OK:

break;

case FINGERPRINT\_NOFINGER:

return p;

case FINGERPRINT\_PACKETRECIEVEERR:

return p;

case FINGERPRINT\_IMAGEFAIL:

return p;

default:

return p;

\117. bool isProtectionOn = true; // current position of the protection function

\118. bool isRFIDChecked = false; // RFID tag check position

\119. bool isFingerChecked = false; // scanned print check position

\120. bool isPinSent = false; // veriﬁcation of sending a message with an unlock code

\121.

122.//-----------------------------------------------------------------------------------------------------

\123.

124.void rﬁdInitialization(){ // RFID module initialization

\125. while (!Serial);

\126. SPI.begin();

\127. mfrc522.PCD\_Init();

\128. delay(4);

\129. mfrc522.PCD\_DumpVersionToSerial();

}

130.}

\131.

p = ﬁnger.image2Tz();

switch (p) {

case FINGERPRINT\_OK:

break;

case FINGERPRINT\_IMAGEMESS:

return p;

case FINGERPRINT\_PACKETRECIEVEERR:

return p;

case FINGERPRINT\_FEATUREFAIL:

return p;

case FINGERPRINT\_INVALIDIMAGE:

return p;

default:

return p;

132.void playSound(int8\_t index, int8\_t volume, int delayTime){ // music playback (sound index, volume, duration)

\133. delay(100);

\134. mp3.playWithVolume(index,volume);

\135. delay(delayTime);

136.}

\137.

138.//-----------------------------------------------------------------------------------------------------

139.void setup(){

\140. digitalWrite(RESET\_PIN, HIGH);

\141. pinMode(RESET\_PIN, OUTPUT);

\142.

\143. Serial.begin(9600);

\144. Serial2.begin(9600);

\145. pinMode(PIN\_TRIG, OUTPUT);

\146. pinMode(PIN\_ECHO, INPUT);

\147. long int t = millis();

\148. digitalWrite(PIN\_TRIG, LOW);

\149. delayMicroseconds(5);

\150. digitalWrite(PIN\_TRIG, HIGH);

\151. delayMicroseconds(10);

\152. digitalWrite(PIN\_TRIG, LOW);

\153. DURATION\_SONAR = pulseIn(PIN\_ECHO, HIGH);

\154. LENGTH\_SONAR = (DURATION\_SONAR / 2) / 29.1;

\155.

}

p = ﬁnger.ﬁngerSearch();

if (p == FINGERPRINT\_OK){

ﬁngerIDS = ﬁnger.ﬁngerID;

}

else if (p == FINGERPRINT\_PACKETRECIEVEERR){

return p;

}

else if (p == FINGERPRINT\_NOTFOUND){

return p;

}

else{

return p;

}

\156.

\157. if (LENGTH\_SONAR > 3){

\158.

\159.

playSound(TRUE\_INPUT\_SOUND\_2, TRUE\_INPUT\_VOLUME, TRUE\_INPUT\_TIME);

sendSms(SETUP\_NOTIFY);

\160. while (key != ‘C’){

\161.

key = keypad.getKey();

\256. void restInPeace(){ // shutdown cycle after self-destruction

\162.

if (key != NO\_KEY){

\257.

while (true){

\163.

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

\258.

playSound(DESTRUCTION\_SOUND, DESTRUCTION\_VOLUME, DESTRUCTION\_TIME);

\164.

Serial.println(key);

\259.

delay(2400);

\165.

}

\260.

}

\166. }

167.}

\168.

\261. }

\262.

\263. void sendSms(String current\_data) {

\169. ﬁnger.begin(57600);

\170. rﬁdInitialization();

\171. accgyro.initialize();

\172. pinMode(PIN\_LOCKS, OUTPUT); //relay 1

\173. pinMode(PIN\_POWER\_SUPPLY, OUTPUT); //relay 2

\174.

\175. digitalWrite(PIN\_POWER\_SUPPLY, HIGH);

\176. //digitalWrite(PIN\_LOCKS, HIGH);

\177.

\264.

\265.

\266.

\267.

\268.

\269.

\270.

\271.

\272.

\273.

\274.

\275.

delay(1000);

Serial2.println(”AT”);

delay(100);

Serial2.println(”AT+CMGF=1”);

delay(200);

Serial2.print(”AT+CMGS=\””);

Serial2.print(PHONE\_NUMBER); // mobile number with country code

Serial2.println(”\””);

delay(500);

\178. ﬁnger.getParameters();

\179. ﬁnger.getTemplateCount();

\180.

Serial2.println(current\_data); // Type in your text message here

delay(500);

Serial2.println((char)26); // This is to terminate the message





\276.

\277.

\278.

delay(1000);

\371.

\372.

\373.

\374.

\375.

\376.

\377.

\378.

\379.

\380.

\381.

\382.

\383.

\384.

\385.

\386. }

\387.

UID\_unsigned = mfrc522.uid.uidByte[0] << 24;

UID\_unsigned += mfrc522.uid.uidByte[1] << 16;

UID\_unsigned += mfrc522.uid.uidByte[2] << 8;

UID\_unsigned += mfrc522.uid.uidByte[3];

}

\279. void sendPin(){

\280.

\281.

\282.

\283.

\284.

\285.

\286.

\287. }

\288.

randomSeed(micros());

String UID\_string = (String)UID\_unsigned;

Serial.println(“SENDING PIN CODE”);

TRUE\_PASSWORD\_UNLOCK = random(100000, 1000000);

notify = “Your veriﬁcation code is “ + TRUE\_PASSWORD\_UNLOCK + “ \nACCESSCODE”;

Serial.println(notify);

sendSms(notify);

isPinSent = true;

Serial.println(UID\_string);

if (UID\_string == TRUE\_RFID\_ID\_1 or UID\_string == TRUE\_RFID\_ID\_2){

playSound(TRUE\_INPUT\_SOUND, TRUE\_INPUT\_VOLUME, TRUE\_INPUT\_TIME);

return true;

}

else {

playSound(FALSE\_INPUT\_SOUND, FALSE\_INPUT\_VOLUME, FALSE\_INPUT\_TIME);

return false;

}

\289. void destruction(){ // self-destruction function

\290.

\291.

\292.

\293.

\294.

\295.

\296.

\297.

\298.

\299.

\300.

\301.

\302.

\303. }

\304.

if (isProtectionOn == false){

digitalWrite(PIN\_POWER\_SUPPLY, HIGH);

}

sendSms(DESTRUCTION\_NOTIFY);

myservo.attach(45);

388.String updateGsm(){

\389. char data;

\390. String result;

\391. String info;

\392. String returnedPassword;

\393. while(Serial2.available())

\394. {

\395.

\396.

\397.

\398. }

\399.

Serial.println(“STARTING SELF-DESTRUCTION”);

for (pos = 0; pos <= 180; pos += 1) {

myservo.write(pos);

delay(10);

}

delay(10);

data = Serial2.read();

result.concat(data);

restInPeace();

\305. void protection(){ // sensor polling protection function

\400. if (result[0] = ”+”){

\306.

\307.

\308.

\309.

\310.

\311.

\312.

\313.

\314.

\315.

\316.

\317.

\318.

\319.

\320.

\321.

\322.

\323.

\324.

\325.

\326.

\327.

\328.

\329.

\330.

\331. }

\332.

Serial.println(“PROTECTION IS RUNNING”);

long int t = millis();

int ax, ay, az, gx, gy, gz;

accgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

digitalWrite(PIN\_TRIG, LOW);

delayMicroseconds(5);

digitalWrite(PIN\_TRIG, HIGH);

delayMicroseconds(10);

digitalWrite(PIN\_TRIG, LOW);

DURATION\_SONAR = pulseIn(PIN\_ECHO, HIGH);

LENGTH\_SONAR = (DURATION\_SONAR / 2) / 29.1;

if (ax > high\_x or ax < low\_x or ay > high\_y or ay < low\_y or az > high\_z or az < low\_z or LENGTH\_SONAR > MAX\_LENGTH\_SONAR){

COUNTER\_EVENTS++;

Serial.println(”TRACKING SENSORS”);

}

if (COUNTER\_EVENTS >= COUNTER\_MAX\_EVENTS){

destruction();

}

COUNTER++;

if (COUNTER >= COUNTER\_LIMIT){

COUNTER = 0;

COUNTER\_EVENTS = 0;

}

\401.

\402. }

\403.

info = result;

\404. if (info != ””){

\405.

\406.

\407.

\408.

\409.

\410.

\411.

\412. }

\413.

for (int i = 10; i < 21; i++){

returnedPassword.concat(info[i]);

}

for (int i = 50; i < 56; i++){

returnedPassword.concat(info[i]);

}

\414. return returnedPassword;

\415.

416.}

\417.

\418. void zeroBools(){

\419.

\420.

\421.

ﬁngerIDS = 0;

isRFIDChecked = false;

isFingerChecked = false;

isPinSent = false;

\422.

\423. }

\424.

delay(50);

\425. void blockSystem(){ // lock function

\426.

\427.

\428.

\429.

\430.

\431.

\432.

\433.

\434.

\435.

\436. }

\437.

isProtectionOn = true;

//digitalWrite(PIN\_LOCKS, HIGH);

digitalWrite(PIN\_POWER\_SUPPLY, HIGH);

Serial.print(”SYSTEM LOCKED”);

zeroBools();

//playSound(BLOCK\_SOUND, BLOCK\_VOLUME, BLOCK\_TIME);

//sendSms(WELCOME\_NOTIFY);

resetFunc();

\333. String passwordInput(){ // function of entering 6-digit codes from the keyboard

\334.

\335.

\336.

\337.

\338.

\339.

\340.

\341.

\342.

\343.

\344.

\345.

\346.

\347.

\348. }

\349.

playSound(TRUE\_INPUT\_SOUND\_2, TRUE\_INPUT\_VOLUME, TRUE\_INPUT\_TIME);

String passkeys;

for (int i = 0; i < 6; i++){

char key = keypad.getKey();

while (key == NO\_KEY){

if (isProtectionOn){

delay(150);

protection();

}

key = keypad.getKey();

}

\438. void openDoors(){ // function of disabling door locks

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

passkeys.concat(key);

\439.

\440.

\441.

\442.

\443.

\444.

\445.

\446.

\447.

\448.

\449.

\450.

\451. }

\452.

\453. void unlockSystem(){

\454.

\455.

\456.

\457.

\458.

\459.

\460. }

\461.

Serial.print(“DOOR OPENED, LOCKS ARE DISABLED”);

sendSms(DOORS\_NOTIFY);

//digitalWrite(PIN\_LOCKS, LOW);

for (int i = 0; i < 12; i++){

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME); // Можно заменить на DOOR\_SOUND

delay(1000);

}

return passkeys;

\350. int checkPassword(char input\_type, String input\_password){ // checking the correctness of the entered code and processing it

}

\351.

\352.

\353.

\354.

\355.

\356.

\357.

\358.

\359.

\360. }

\361.

if ((input\_type == ‘A’ && input\_password == TRUE\_PASSWORD\_UNLOCK) or (input\_password == MASTER\_PASSWORD)){

return 1; // return 1 if the login password was checked and the password was entered correctly

}

else if (input\_type == ‘D’ && input\_password == TRUE\_PASSWORD\_DESTRUCT){

return 2; // return 2 if the self-destruction password was checked and the password was entered correctly

}

else {

return 3;

}

for (int i = 0; i < 3; i++){

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME); // Можно заменить на DOOR\_SOUND

delay(50);

}

//digitalWrite(PIN\_LOCKS, HIGH);

isProtectionOn = false;

zeroBools();

digitalWrite(PIN\_POWER\_SUPPLY, LOW);

playSound(UNLOCK\_SOUND, UNLOCK\_VOLUME, UNLOCK\_TIME);

Serial.println(”SYSTEM UNLOCKED”);

sendSms(UNLOCK\_NOTIFY);

\362. bool checkRFID(){ // veriﬁcation of the correctness of the presented RFID key

\363.

\364.

\365.

\366.

\367.

\368.

\369.

\370.

if ( ! mfrc522.PICC\_IsNewCardPresent()) {

return false;

}

if ( ! mfrc522.PICC\_ReadCardSerial()) {

return false;

}

\462. void loop(){

\463.

\464.

\465. }

if (isProtectionOn){

protection();

unsigned long UID\_unsigned;






\466.

\467. if (isRFIDChecked != true && isProtectionOn){

\468.

\469.

\470.

isRFIDChecked = checkRFID();

}

\471. if (isRFIDChecked && isProtectionOn){

\472.

\473.

\474.

\475.

\476.

\477.

\478.

\479.

\480.

\481.

\482.

\483.

\484.

\485.

\486.

\487.

\488.

\489.

\490.

\491.

\492.

\493.

\494.

\495.

\496.

\497.

\498.

\499.

\500.

\501.

\502.

\503.

\504.

\505.

\506.

\507.

\508.

\509.

\510.

\511.

\512.

\513.

\514.

\515.

\516.

\517.

\518.

\519.

\520.

\521.

\522.

\523.

\524.

\525.

\526.

\527.

\528.

\529.

\530.

\531.

\532.

\533.

\534.

\535.

\536.

\537.

\538.

\539.

\540.

\541.

\542.

\543.

\544.

\545.

\546.

\547.

\548.

\549.

\550.

\551.

\552.

\553.

\554.

\555.

\556.

\557.

\558.

\559.

\560.

if (isFingerChecked != true){

recieveFingerprint();

isFingerChecked = checkFingerprint(ﬁngerIDS);

Serial.print(isFingerChecked);

key = keypad.getKey();

if (key != NO\_KEY){

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

Serial.println(key);

if (key == ‘\*’){

delay(100);

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

zeroBools();

}

}

}

else {

if (isPinSent == false){

sendPin(); // генерирует pin, отправляет pin, назначает pin

}

else {

key = keypad.getKey();

if (key != NO\_KEY){

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

Serial.println(key);

if (key == ‘A’ or key == ‘D’){

Serial.println(“PASS IS BEING ENTERED”);

String enteredPassword = passwordInput();

Serial.println(enteredPassword);

int checkedTypeOfPassword = checkPassword(key, enteredPassword);

if (checkedTypeOfPassword == 1){

unlockSystem();

}

else if (checkedTypeOfPassword == 2){

destruction();

}

else if (checkedTypeOfPassword == 3){

playSound(FALSE\_INPUT\_SOUND, FALSE\_INPUT\_VOLUME, FALSE\_INPUT\_TIME);

}

}

else if (key == ‘\*’){

delay(100);

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

zeroBools();

}

}

}

}

}

else {

key = keypad.getKey();

if (key != NO\_KEY){

playSound(KEYBOARD\_SOUND, KEYBOARD\_VOLUME, KEYBOARD\_TIME);

Serial.println(key);

if (key == ‘D’){

Serial.println(“PASS IS ENTERING”);

String enteredPassword = passwordInput();

Serial.println(enteredPassword);

int checkedTypeOfPassword = checkPassword(key, enteredPassword);

if (checkedTypeOfPassword == 2){

destruction();

}

else {

playSound(FALSE\_INPUT\_SOUND, FALSE\_INPUT\_VOLUME, FALSE\_INPUT\_TIME);

}

}

if (key == ‘B’ && isProtectionOn == false){

blockSystem();

}

if (key == ‘C’ && isProtectionOn == false){

openDoors();

}

}

}

messageCheck = updateGsm();

if (messageCheck.equals(SELF\_DESTRUCTION\_SMS)){

destruction();

}

if (messageCheck.equals(UNLOCK\_SMS) && isProtectionOn){

unlockSystem();

}

if (messageCheck.equals(LOCK\_SMS) && isProtectionOn == false){

blockSystem();

}

}


